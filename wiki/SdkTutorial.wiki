#summary First steps in SDK.

=ChromeDevTools SDK Tutorial=

==Overview==
SDK is a standalone Java library. It comes as a set of .jar files or as an Eclipse plugins. As of 0.3.0 version it supports 'DevTools' protocol[], native V8 protocol and WebKit Debug Protocol[]. All of them implement the same API and differs only in attach interfaces. WebKit Debug Protocol support is a new subproject called here “WIP” (stands historically for WebInspector Protocol). Several concurrent WIP implementations are deployed simultaneously in modules called Wip Backends. Each of them corresponds to a particular version of WebKit Debug Protocol (see details in release notes[]). As of 0.3.0 it is user's responsibility to choose the correct backend. 

==Getting started==
1. Eclipse framework. Install FEATURE or manually install all org.chromium.sdk* packages.
2. Non-Eclipse framework. Get all .jar files of SDK. Put all of them in your classpath, except for backend jars. You should pick only one of them, because they contain different versions of the same classes.

==Attaching to JavaScript VM==
Attachment is the part where API diverges.
===1. 'DevTools'[] protocol.===
{{{
Browser browser = BrowserFactory.getInstance().create(new InetSocketAddress(“localhost”, “9222”), null);
TabFetcher tabFetcher = browser.createTabFetcher();
List<? extends TabConnector> tabList = tabFetcher.getTabs();
// Choose your tab somehow.
BrowserTab tab = tabList.get(<choose your tab>).attach(listener);
JavascriptVm javascriptVm = tab;
tabFetcher.dismiss(); // TabFecther is needed to accurately manage single shared connection to Browser.
}}}
===2. WIP[]===
{{{
WipBrowser browser = WipBrowserFactory.INSTANCE.createBrowser(
    new InetSocketAddress(“localhost”, “9222”), null);
WipBackend backend;
#ifdef ECLIPSE
backend = BackendRegistry.INSTANCE.getBackends().get(<choose your backend>); 
#else
WipBackendFactory backendFactory = new WipBackendFactory(); // Same class name in each backend .jar 
backend = backendFactory.create();
#endif
WipBrowserTab tab = browser.getTabs(backend).get(<choose your tab>).attach(listener);
JavascriptVm javascriptVm = tab.getJavascriptVm()
}}}
===3. Standalone Javascript VM===
{{{
StandaloneVm standaloneVm =
    BrowserFactory.getInstance().createStandalone(new InetSocketAddress(“localhost”, “9222”), null);
standaloneVm.attach(listener);
JavascriptVm javascriptVm =  standaloneVm;
}}}
==First steps==
The API is pretty much straightforward. For example you can try to set a breakpoint:
{{{
javascriptVm.setBreakpoint(new Breakpoint.Target.ScriptName(“index.html”),
    5, // line
    1, // column
    true, null, null, null); // other parameters.
}}}
Hopefully some time later the VM will pause on this breakpoint. Your program should learn about it from the DebugEventListener.

==DebugEventListener==
What is called simply 'listener' in the previous section is a central part of SDK API. That's how your program learns about new events in Javascript VM. Once you attached, SDK will call your listener in asynchronous manner.

This makes it difficult to simply play around with SDK, because your program is essentially multi-threaded. However, for the scripting purposes you can safely ignore most of the events except for 'suspended':
{{{
class SimpleListener implements DebugEventListener {
  DebugContext savedDebugContext;
  final Semaphore semaphore = new Semaphore(0); 
  @Override public void suspended(DebugContext debugContext) {
    savedDebugContext = debugContext;
    semaphore.release();
  }
  @Override public void scriptLoaded(Script script) {
    // ignore
  }
  ...
}
in the main code:
// Let's patiently wait for our breakpoint to hit.
boolean res = listener.semaphore.tryAcquire(5, TimeUnit.HOURS);
if (!res) {
  throw new RuntimeException(“Bad luck”);
}
DebugContext debugContext = listener.savedDebugContext;
// Let's get stacktrace.
List<? extends CallFrame> stackTrace = debugContext.getCallFrames();
// Now we can see local variables!
}}}

==SDK Thread Model==
SDK is multi-threaded library. First of all it means that you can call its methods from different threads (with some reasonable limitations of course). Secondly it means that SDK itself will call you asynchronously. All the calls to your listener are made from a single thread called Dispatch Thread. This thread is allocated one per connection. The good news is that you can rely on the fact that all events are coming consequently. The bad news is that you should be careful and return from the callbacks promptly. In particular you cannot call certain blocking methods of API, because it's a certain deadlock (you cannot block the road and waiting for another car to come at the same time). 

==Blocking and non-blocking method.==
In the API there are some methods that work completely locally. For example JavascriptVm.getVersion() will simply return a field. Other methods create requests that are sent over wire to JavaScript VM and wait for the response to (hopefully) come back.
This latter kind of methods could be implemented in 2 styles. SDK has an example of both styles:

1. Blocking/Synchronous. The method conveniently returns result to caller. For example JsObject.getProperties() works like this. What may be inconvenient is that you have to have a dedicated thread for the time of entire operation. And you cannot call this methods from SDK callbacks and listeners, because you would stop the Dispatch Thread forever.

2. Non-blocking/Asynchronous. The method doesn't return result. Instead it sends the corresponding request and returns control to you. You have to provide a callback that will be called (from Dispatch Thread) some time in the future when the result is there. This is more powerful comparing to Blocking approach, but is obviously less useful.

SDK combines both approaches optimized for the typical use: some methods are blocking, some asynchronous. Some methods come in 2 styles, like in JsEvaluateContext.

Some methods are blocking, but they still requires a callback. That's needed in some cases because:
  # callback can accept both error and result, while in Java method can only return 1 type,
  # SDK pass a value to callback and hold all changes for the time of method work – a thing you can't do with a return type. 

==Recurring helper types: SyncCallback, RelayOk etc==
There are certain patterns how methods are written in SDK API. All blocking methods throw MethodIsBlocking exception. All asynchronous methods return RelayOk and accept SyncCallback parameter. In the first approach these types could be safely ignored.

They are here to help writing more safe program. Java is a pretty safe language, however dealocks (and infinite loops) still remain an actual problem.
  
===SyncCallback===
All asynchronous methods accept 2 callbacks. One is 'logical': it receives and processes data, it can fail and in case of failure it may not be called at all. The second is SyncCallback; if async method hasn't thrown an exception, it is guaranteed to be called in any case one time after the operation finished. The callback itself shouldn't throw exceptions. In a way it's like a finally block in Java, but asynchronous. It should be used for thread synchronization and when needed for resource deallocation.
You can implement SyncCallback yourself or you can use default implementation for simple synchronization.
{{{
// Enable breakpoints
class LogicCallback new BreakpointCallback() {
  Breakpoint result = null;
  @Override public void success(Breakpoint breakpoint) {
    result = breakpoint;
  }
  @Override public void failure(String errorMessage) {
    System.out.println(“Problem: “ + errorMessage);
  }
};
LogicCallback callback = new LogicCallback();
SyncCallback syncCallback = new CallbackSemaphore();
RelayOk relayOk = javascriptVm.setBreakpoint(new Breakpoint.Target.ScriptName(“index.html”),
    5, 1, true, “a > 5”, callback, syncCallback);
// Wait when for operation to finish.
// Wait for syncCallback, not a callback.
syncCallback.acquireDefault(relayOk);
}}}

===RelayOk===
This a 'symbolic' type. It means that asynchronous methods guarantees to call a SyncCallback. Note in the snippet above how method acquireDefault doesn't let you forget to call asynchronous method first.
It also helps to write new asynchronous methods correctly (doesn't let mistakenly return before actually sending request).

===MethodIsBlockingException===
This exception annotates all blocking methods. It helps to check that you never call blocking methods from callbacks (which is a certain deadlock). To do it simply make 'MethodIsBlockingException' extend 'Exception' (by default it extends 'RuntimeException'): edit sources or create your own class that overrides class from jar file. In this temporary set-up you would have to annotate all your methods that call blocking methods. This way you can track all incorrect calls and annotate correct calls with symbolic try/catch blocks.

==Extensions==
Some features of SDK are optional. Depending on backend version or JavaScript VM version they may or may not be available. As of 0.3.0 there are following extensions:
'regexp' breakpoint target type (works everywhere except old V8 versions)
'function' breakpoint target type (doesn't work in WIP)
breakpoint 'ignore count' property (doesn't work in WIP)
evaluate with 'target mapping' parameter (WIP only)
All extensions are designed:
  * to be fully separate from the standard API;
  * as objects that are available as early as possible; for example IgnoreCountBreakpointExtension is available from JavascriptVM interface; this way you can prepare to 'ignore count' not being available (e.g. disable UI) before any breakpoint actually created.